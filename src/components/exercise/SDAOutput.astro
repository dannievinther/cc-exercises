---
const { boxContent = "I'm a box", startingHTML, markers = false } = Astro.props;
---

<div class="sda-result output">
  <div class="container" data-markers={markers} set:html={startingHTML} />
</div>

<style>
  .sda-result {
    --padding: var(--space-2);
    overscroll-behavior: contain;
    container: sda-result / size var(--scroll-state-not-supported, scroll-state);
    background:
      var(
        --marching-ants,
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E@keyframes ant %7Bto %7Bstroke-dashoffset: -8;%7D%7D%3C/style%3E%3Crect width='100%25' height='100%25' style='stroke: %23a9bcce; stroke-width: 3.75px; fill: none;stroke-dasharray: 5 3; animation: ant 0s infinite linear'/%3E%3C/svg%3E")
          border-box
      ),
      conic-gradient(
          from 90deg at 1px 1px,
          #0000 25%,
          oklch(from var(--ui-primary) 0.95 0.025 h) 0
        ) -0.5px
        0px / 25px 25px round local content-box,
      oklch(from var(--ui-primary) 0.99 0.01 h) content-box;
    border-radius: var(--bdrs-sm);
    min-height: 300px;
    overflow-y: auto;
    position: relative;
    padding: 0.5lh;
    border: 2px dashed transparent;
    padding: var(--padding);
    margin: calc(var(--padding) * -1);

    position: sticky;
    top: 1rem;

    @supports not (container: sda-result / size scroll-state) {
      --scroll-state-not-supported: ;
    }

    &::before,
    &::after {
      content: "";
      display: grid;
      place-content: center;
      block-size: calc(100% + 1rlh);
      content: "Scroll ↓";
      translate: 0 -1lh;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--ui-primary-border);
    }
    &::after {
      content: "Scroll ↑";
      translate: 0 1rlh;
    }

    .container {
      padding: 1lh;

      .frame {
        display: grid;
      }
    }

    .container[data-markers="true"] {
      outline: 1px dashed;
      outline-offset: -1px;
      position: relative;
      color: var(--ui-primary-dark);
      &::before {
        content: ".container";
        position: absolute;
        inset: -1.2cap 0 auto 0;
        justify-self: center;
        font-size: 0.8em;
        background: oklch(from var(--ui-primary) 0.99 0.01 h);
        padding-inline: 0.5ch;
        pointer-events: none;
      }
      .frame {
        color: var(--ui-primary-border);
        outline: 1px dashed;
        outline-offset: -1px;
        &::before {
          content: ".frame";
          position: absolute;
          inset: -1.2cap 0 auto 0;
          justify-self: center;
          font-size: 0.8em;
          background: oklch(from var(--ui-primary) 0.99 0.01 h);
          padding-inline: 0.5ch;
          pointer-events: none;
        }
      }
    }

    .output:is(.editor:has(:focus-within) ~ &) {
      --marching-ants: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E@keyframes ant %7Bto %7Bstroke-dashoffset: -8;%7D%7D%3C/style%3E%3Crect width='100%25' height='100%25' style='stroke: %23a9bcce; stroke-width: 3.75px; fill: none;stroke-dasharray: 5 3; animation: ant 1s infinite linear'/%3E%3C/svg%3E")
        border-box;

      /* border-color: transparent; */
      /* transition: filter 0.15s; */
    }

    .box {
      background: var(--ui-primary);
      color: var(--ui-primary-border);
      padding: var(--space-4) var(--space-6);
      border-radius: var(--bdrs-md);
      font-weight: 600;
      font-size: 0.875rem;
      box-shadow:
        0 0 0 1px var(--ui-primary-dark),
        0 2px 2px rgba(0, 90, 250, 0.05),
        0 4px 4px rgba(0, 90, 250, 0.05),
        0 8px 8px rgba(0, 90, 250, 0.05),
        0 16px 16px rgba(0, 90, 250, 0.05);
    }
  }
</style>
